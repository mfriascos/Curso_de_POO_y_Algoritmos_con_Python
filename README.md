# Curso_de_POO_y_Algoritmos_con_Python

**Curso de Propgramaci√≥n Orientada a Objetos y Algoritmos con Python** 

<h1 align="center">Hi üëã, I'm Mario Riascos</h1>
<h3 align="center">An electronic and telecomunications engineer of profession, i am apassionate for backend development from Colombia!</h3>

- üå± I‚Äôm currently learning **Frameworks, Djando, Flask, ApiRest, Odoo, Pythond development, backend, Html, CSS, git, mysql**

- üë®‚Äçüíª All of my projects are available at [https://github.com/mfriascos?tab=repositories](https://github.com/mfriascos?tab=repositories)

- üì´ How to reach me **marioriascos1201@gmail.com**

- ‚ö° Fun fact **I think i am funny**

<h3 align="left">Connect with me:</h3>
<p align="left">
<a href="https://twitter.com/@mariofeernando" target="blank"><img align="center" src="https://raw.githubusercontent.com/rahuldkjain/github-profile-readme-generator/master/src/images/icons/Social/twitter.svg" alt="@mariofeernando" height="30" width="40" /></a>
<a href="https://linkedin.com/in/mario-f-riascos1" target="blank"><img align="center" src="https://raw.githubusercontent.com/rahuldkjain/github-profile-readme-generator/master/src/images/icons/Social/linked-in-alt.svg" alt="mario-f-riascos1" height="30" width="40" /></a>
<a href="https://fb.com/mario.f.riascos" target="blank"><img align="center" src="https://raw.githubusercontent.com/rahuldkjain/github-profile-readme-generator/master/src/images/icons/Social/facebook.svg" alt="mario.f.riascos" height="30" width="40" /></a>
</p>

<h3 align="left">Languages and Tools:</h3>
<p align="left"> <a href="https://www.arduino.cc/" target="_blank" rel="noreferrer"> <img src="https://cdn.worldvectorlogo.com/logos/arduino-1.svg" alt="arduino" width="40" height="40"/> </a> <a href="https://www.djangoproject.com/" target="_blank" rel="noreferrer"> <img src="https://cdn.worldvectorlogo.com/logos/django.svg" alt="django" width="40" height="40"/> </a> <a href="https://www.docker.com/" target="_blank" rel="noreferrer"> <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/docker/docker-original-wordmark.svg" alt="docker" width="40" height="40"/> </a> <a href="https://flask.palletsprojects.com/" target="_blank" rel="noreferrer"> <img src="https://www.vectorlogo.zone/logos/pocoo_flask/pocoo_flask-icon.svg" alt="flask" width="40" height="40"/> </a> <a href="https://git-scm.com/" target="_blank" rel="noreferrer"> <img src="https://www.vectorlogo.zone/logos/git-scm/git-scm-icon.svg" alt="git" width="40" height="40"/> </a> <a href="https://www.java.com" target="_blank" rel="noreferrer"> <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/java/java-original.svg" alt="java" width="40" height="40"/> </a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="noreferrer"> <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/javascript/javascript-original.svg" alt="javascript" width="40" height="40"/> </a> <a href="https://www.linux.org/" target="_blank" rel="noreferrer"> <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/linux/linux-original.svg" alt="linux" width="40" height="40"/> </a> <a href="https://www.mathworks.com/" target="_blank" rel="noreferrer"> <img src="https://upload.wikimedia.org/wikipedia/commons/2/21/Matlab_Logo.png" alt="matlab" width="40" height="40"/> </a> <a href="https://www.mysql.com/" target="_blank" rel="noreferrer"> <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/mysql/mysql-original-wordmark.svg" alt="mysql" width="40" height="40"/> </a> <a href="https://www.postgresql.org" target="_blank" rel="noreferrer"> <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/postgresql/postgresql-original-wordmark.svg" alt="postgresql" width="40" height="40"/> </a> <a href="https://www.python.org" target="_blank" rel="noreferrer"> <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/python/python-original.svg" alt="python" width="40" height="40"/> </a> </p>

**********************************************************************************************************************************************
<h2>CONTENT LIST</h2>

- [Programaci√≥n Orientada a Objetos](#programaci√≥n-orientada-a-objetos)
    - [Clases en Python](#clases-en-python)
    - [Instancias](#instancias)
    - [Atributos de la Instancia](#atributos-de-la-instancia)
    - [M√©todos de Instancia](#m√©todos-de-instancia)
- [Tipos de Datos Abstractos y clases, Instancias](#tipos-de-datos-abstractos-y-clases-instancias)
    - [Instancias](#instancias)
    - [Decomposici√≥n](#decomposici√≥n)
    - [Abstracci√≥n](#abstracci√≥n)
- [Funciones: Base de los Decoradores](#funciones-base-de-los-decoradores)
- [Setters, Getters y Decorador Property](#setters-getters-y-decorador-property)
- [Herencia](#herencia)
- [Introducci√≥n a la Complejidad Algoritmica](#introducci√≥n-a-la-complejidad-algoritmica)
	- [Aproximaciones](#aproximaciones)
- [Algoritmos de B√∫squeda y Ordenaci√≥n](#algoritmos-de-b√∫squeda-y-ordenanci√≥n)
	- [B√∫squeda Lineal](#b√∫squeda-lineal)
	- [B√∫squeda Binaria](#b√∫squeda-binaria)
- [Ordenamiento de Burbuja](#ordenamiento-de-burbuja)
- [Ordenamiento por Inserci√≥n](#ordenamiento-por-inserci√≥n)
- [Ordenamiento por Mezcla](#ordenamiento-por-mezcla)
- [Ambientes Virtuales](#ambientes-virtuales)



# Programaci√≥n Orientada a Objetos

Uno de los elementos m√°s importantes de los lenguajes de programaci√≥n es la utilizaci√≥n de clases para organizar programas en m√≥dulos y abstracciones de datos. 

Las clases se pueden utilizar de diversas maneras. Pero en este art√≠culo hablaremos de c√≥mo utilizarlas en el contexto de la programaci√≥n orientada a objetos. La clave para entender la programaci√≥n orientada a objetos es pensar en objetos como agrupaciones de datos y los m√©todos que operan en dichos datos. 

Por ejemplo, podemos representar a una persona con propiedades como nombre, edad, g√©nero, etc. y los comportamientos de dicha persona como caminar, cantar, comer, etc. De la misma manera podemos representar unos audifonos con propiedades como su marca, tama√±o, color, etc. Y sus comportamientos como reproducir m√∫sica, pausar y acanzar a la sihiente canci√≥n 

Puesto de otra manera, la programaci√≥n orientada a objetos tienen m√°s de 50 a√±os y han sido ampliamente aceptadas y practicadas en los √∫ltimos treinta. A mediados de la decada de los setentase comenzaron a escribir art√≠culos acad√©micos explicando los beneficios de esta aproximaci√≥n a la programaci√≥n. Tambi√©n durante estos a√±os se comenzaron a escribir los primeros lenguajes de programaci√≥n que incorporaban estas ideas (como Smalltalk y CLU). Pero no fue hasta la llegada de java y C++ que la idea consigui√≥ un n√∫mero importante de seguidores. 

Hasta ahora, en el curso previo de esta serie hemos utilizado programaci√≥n orientada a objetos de manera √≠mplicita. Cuando decimos "Los objetos son las principales cosas que un programa de python manipula. Cada objeto tiene un tipo que define qu√© cosas puede realizar un programa con dicho objeto", nos estamos refiriendo a las ideas principales de la programaci√≥n orientada a objetos. Hemos utilizado los tipos lista y diccionario, entre muchos otros, as√≠ como los m√©todos asociados a dichos tipos. 

As√≠ como los creadores de un lenguaje de programaci√≥n s√≥lo puede dise√±ar una fracci√≥n muuy peque√±a de todas las funciones √∫tiles (como abs, float, type, etc.), tambi√©n pueden escribir una fracci√≥n muy peque√±a de los tipos √∫tiles (int, str, dict, list, etc.). Ya sabemos los mecanismos que nos permiten crear funciones, ahora veremos los mecanismos que nos permiten crear nuevos tipos (o clases). 

## Clases en Python 

Las estructuras primitivas con las que hemos trabajado hasta ahora nos permiten definir cosas sencillas, como el costo de algo, el nombre de un usuario, las veces que debe correr un bucle, etc. sin embargo, existen ocasiones cuando necesitamos definir estructuras m√°s complejas, por ejemplo un hotel. Podr√≠amos utilizar dos listas: una para definir los cuartos y una segunda para definir si el cuarto se encuentra ocupado o no. 

```python
cuartos_de_hotel = [101,102,103,201,202,203]
cuarto_ocupado = [True,False,False,True,True,False]
```
Sin embargo, este tipo de organizaci√≥n r√°pidamente se sale de control. ¬ø Qu√© tal que quisi√©ramos a√±adir m√°s propiedades, c√≥mo si el cuarto ya fue aseado o no? ¬øSi el cuarto tiene cama doble o sencilla? Esto nos lleva a una falta fuerte de organizaci√≥n y es justamente el punto que justifica la existencia de clases. 

Las clases nos permiten crear nuevos tipos que contienen informaci√≥n arbitraria sobre un objeto. En el caso del hotel podr√≠amos crear dos clases Hotel() y Cuarto() que nos permitiera dar seguimiento a las propiedades como n√∫mero de cuarto, ocupaci√≥n, aseo, tipo de habitaci√≥n, etc.

Es importante resaltar que las clases solo proveen estructura. son un molde con el cual podemos construir objetos espec√≠ficos. La clases se√±ala las propiedades que los hoteles que modelemos tendr√°n, pero no es ning√∫n hotel espec√≠fico. Para eso necesitamos las instancias. 

## Instancias

Mientras que las clases proveen la estructura, las instancias son los objetos reales que creamos en nuestro programa: un hotel llamado PlatziHotel o Hilton. Otra forma de pensarlo es que las clases son como un formulario y una que se llena cada copia del formulario tenemos las instancias que pertenecesn a dicha clase. Cada copia puede tener datos distintos, al igual que cada instancia es distinta de las dem√°s (aunque todas pertenecen a una misma clase).

Para definir una clase, simplemente utilizamos el *keyword* **class**. Por ejemplo:

```python
class Hotel:
    pass
```
Una vez que tenemos una clase llamada **Hotel** podemos generar una instancia llamando al constructor de la clase. 

```python
hotel = Hotel()
```

## Atributos de la Instancia

Todas las clases crean objetos y todos los objetos tienen atributos. Utilizams el m√©todo especial _ _ init _ _ para definir el estado inicial de nuestra instancia. Recibe como primer par√°metro obligatorio self( que es simplemente una referencia a la instancia).

```python
class Hotel: 

    def __init__(self, numero_maximo_de_huespedes, lugares_de_estacionamiento):
        self.numero_maximo_de_huespedes = numero_maximo_de_huespedes
        self.lugares_de_estacionamiento = lugares_de_estacionamiento
        self.huespedes = 0

hotel = Hotel(numero_maximo_de_huespedes=50, lugares_de_estacionamiento=20)
print(hotel.lugared_de_estacionamiento) #20
```

## M√©todos de Instancia 

Mientras que los atributos de la instancia describen lo que representa el objeto, los m√©todos de instancia nos indican qu√© podemos hacer con las instancias de dicha clase y normalmente operan en los mencionados atributos. Los m√©todos son equivalentes a funciones dentro de la definici√≥n de la clase, pero todos reciben self como primer argumento. 

```Python
class Hotel:

    ...

    def anadir_huespedes(self, cantidad_de_huespedes):
        self.huespedes += cantidad_de_huespedes

    def checkout(self, cantidad_de_huespedes):
        self.huespedes -= cantidad_de_huespedes

    def ocupacion_total(self)
        return self.huespedes
    
hotel = Hotel(50,20)
hotel.anadir_huespedes(3)
hotel.checkout(1)
hotel.ocupacion_total() #2
```
# Tipos de Datos Abstractos y clases, Instancias

En Python todo es un objeto y tiene un tipo
* Representaci√≥n de datos y formas de interactuar con ellos. 

formas de interactuar con un objeto
* Creaci√≥n 
* Manipulaci√≥n 
* Destrucci√≥n 

Ventajas: 
* Decomposici√≥n -> Es decir, estructurar objetos m√°s peque√±os
* Abstraccci√≥n  
* Encapsulaci√≥n -> Esconder ciertos datos que no son importantes para ciertas personas 

```Python 
# Definici√≥n de clase 

class <nombre_de_la_clase>(<super_clase>):

    def __init__(self, <params>):           #Se definen los parametros de inicializaci√≥n 
        <expresi√≥n>                         #Esta expresi√≥n puede ser vac√≠a o se puede inicializar la clase 
    
    def <nombre_del_metodo>(self,<params>): #Define la funcionalidad de la clase 
        <expresi√≥n>
```
**Ejemplo**

```Python
# Definici√≥n 
class Persona:

    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

    def saluda(self, otra_persona):
        return f"Hola {otra_persona.nombre}, me llamo {self.nombre}."

# Uso
>>> david = Persona('David',35)
>>> erika = Persona('Erika',32)

>>> david.saluda(erika)
"Hola Erika, me llamo David"
```

## Instancias

* Mientras que la clase es un molde, a los objetos creados se les conoce como instancias. 
* Cuando se crea una instancia , se ejecuta el m√©todo __ init __
* Todos los m√©todos de una clase reciben impl√≠citamente como primer par√°metro *self*
* Los atributos de clase nos permiten:
    * Representar datos 
    * Procedimientos para interactuar con los mismos(m√©todos)
    * Mecanismos para esconder la representaci√≥n interna 
* Se accede a los atributos con la notaci√≥n de punto. 
* Puede tener atributos privados. Por convenci√≥n comienza con _

```Python
class Coordenada:

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def distancia(self, otra_coordendada):
        x_diff = (self.x - otra_coordendada.x)**2
        y_diff = (self.y - otra_coordendada.y)**2

        return (x_diff + y_diff)**0.5


if __name__ == '__main__':
    coord_1 = Coordenada(3, 30)
    coord_2 = Coordenada(4, 8)

    #print(coord_1.distancia(coord_2))
    print(isinstance(coord_2,Coordenada))   # Nos permite determinar si alguna de estas coordenadas es instancia
                                            # de coordenada
```

## Decomposici√≥n 
* Partir un problema en problemas m√°s peque√±os. 
* Las clases permiten crear mayores abstracciones en forma de componentes. 
* Cada clase se encarga de una parte del problemas y el programa se vuelve m√°s f√°cil de entender. 

## Abstracci√≥n 

* Enfocarnos en la informaci√≥n relevante 
* Separar la informaci√≥n central de los detalles secundarios 
* Podemos utilizar variables y m√©todos (privados o p√∫blicos)

# Funciones: Base de los Decoradores 

El concepto de decorador en Python es algo que podr√≠amos ubicar en un nivel ‚Äúintermedio‚Äù en el manejo del lenguaje, por lo que es buena idea que tengas una base s√≥lida, sobre todo en cuanto a funciones al momento de profundizar e implementarlas.

Los decoradores son una forma sencilla de llamar **funciones de orden mayor**, es decir, funciones que toman otra funci√≥n como par√°metro y/o retornan otra funci√≥n como resultado. De esta forma un decorador a√±ade capacidades a una funci√≥n sin modificarla.

Un ejemplo de esto son las llantas de un autom√≥vil. Si les colocas cadenas para la nieve, el autom√≥vil a√∫n puede andar y adem√°s extiende su funcionalidad para conducirse en otros terrenos.

<h2>Recordando sobre funciones</h2>

Antes de abordar el tema de decoradores haremos un peque√±o repaso por las funciones, las cuales retornan un valor ante la entrada de un argumento.

Analicemos este sencillo ejemplo donde una funci√≥n que multiplica un n√∫mero se eleva a la tercera potencia:
```python
def elevar_cubo(numero):
	return numero * numero * numero
```
Si damos como argumento el n√∫mero 3, entonces tendremos como salida el n√∫mero 27 al ejecutar la funci√≥n:
```python
>>> elevar_cubo(3)
27
```

<h2>Funciones como objetos de primera-clase</h2>

Otro concepto importante a tener en cuenta es que en Python las funciones son objetos de primera-clase, es decir, que pueden ser pasados y utilizados como argumentos al igual que cualquier otro objeto (strings, enteros, flotantes, listas, etc.).

Veamos un ejemplo donde definimos 3 diferentes funciones que utilizaremos de manera conjunta:
```python
def presentarse(nombre):
	return f"Me llamo {nombre}"

def estudiemos_juntos(nombre):
	return f"¬°Hey {nombre}, aprendamos Python!"

def consume_funciones(funcion_entrante):
	return funcion_entrante("David")
```

Las primeras dos funciones son obvias en su resultado, donde nos mostrar√°n un mensaje con el valor de la variable nombre. La tercera funci√≥n puede ser m√°s compleja de predecir, ya que toma otra funci√≥n como entrada. Veamos que pasa cuando colocamos una funci√≥n como atributo:
```python
>>> consume_funciones(presentarse)
'Me llamo David'

>>> consume_funciones(estudiemos_juntos)
'¬°Hey David, aprendamos Python!'
```
Pongamos atenci√≥n en c√≥mo la funci√≥n consume_funciones() se escribe con par√©ntesis para ser ejecutada, mientras que la funci√≥n presentarse y estudiemos_juntos solo hace referencia a estas.

<h2>Funciones anidadas</h2>

Al igual que los condicionales y bucles tambi√©n puedes colocar funciones dentro de otra funci√≥n.

T√≥mate un minuto para analizar el siguiente c√≥digo e inferir cu√°l ser√° el resultado de salida:
```python
def funcion_mayor():
	print("Esta es una funci√≥n mayor y su mensaje de salida.")

	def librerias():
		print("Algunas librer√≠as de Python son: Scikit-learn, NumPy y TensorFlow.")

	def frameworks():
		print("Algunos frameworks de Python son: Django, Dash y Flask.")

	frameworks()
	librerias()
```

Si llamamos a la funci√≥n funcion_mayor tendremos la siguiente salida:
```python
>>> funcion_mayor()
Esta es una funci√≥n mayor y su mensaje de salida.
Algunos frameworks de Python son: Django, Dash y Flask.
Algunas librer√≠as de Python son: Scikit-learn, NumPy y TensorFlow.
```

Debemos considerar que las funciones anidadas dentro de funcion_mayor no se ejecutan hasta que se llama a esta primera, siendo muestra del scope o alcance de las funciones. Si las llamamos obtendremos un error

En la siguiente lectura entraremos al concepto de decoradores, setters y getters, pues al entender mejor las funciones ser√° m√°s f√°cil asimilar su uso en la implementaci√≥n del encapsulamiento.

# Setters, Getters y Decorador Property

En este punto estamos comenzando a utilizar conceptos en Python que comienzan a ser m√°s avanzados, por lo que es normal que puedan parecerte complejos o dif√≠ciles de asimilar, as√≠ que te animo a que los repases un par de veces.

Puedes tener la tranquilidad de que si bien, al inicio, no los implementas en su totalidad, podr√°s seguir avanzando en el curso y poco a poco incorporarlos a tus proyectos donde lo m√°s importante es que sepas que cuentas con estas herramientas.

<h2>Entendiendo el concepto de decorador</h2>

Antes de comenzar me gustar√≠a que analices el siguiente c√≥digo:

```python
def funcion_decoradora(funcion):
	def wrapper():
		print("Este es el √∫ltimo mensaje...")
		funcion()
		print("Este es el primer mensaje ;)")
	return wrapper

def zumbido():
	print("Buzzzzzz")

zumbido = funcion_decoradora(zumbido)
```

¬øQu√© pasar√° si llamamos a la funci√≥n zumbido()? Si logras determinar el resultado de salida o entenderlo con detalle, entonces podemos seguir adelante.

Lo que sucede es lo siguiente:

```python
>>> zumbido()
Este es el √∫ltimo mensaje...
Buzzzzzz
Este es el primer mensaje ;)
```

Si no diste con el resultado no te preocupes, solo hay que analizarlo con detalle y el truco est√° en la l√≠nea zumbido = funcion_decoradora(zumbido). Sucede que la funci√≥n wrapper() recibi√≥ la funci√≥n zumbido() como par√°metro y coloca su salida entre los otros dos prints.

Todo lo que sucede se conoce en programaci√≥n como metaprogramaci√≥n (metaprogramming), ya que una parte del programa trata de modificar a otra durante el tiempo de compilaci√≥n. En tanto, un decorador b√°sicamente toma una funci√≥n, le a√±ade alguna funcionalidad y la retorna.

<h2>Mejorando la sintaxis</h2>

Definitivamente, la forma en que decoramos la funci√≥n es complejo, pero afortunadamente Python lo tiene en cuenta y podemos utilizar decoradores con el s√≠mbolo @. Volviendo al mismo ejemplo de funcion_decoradora(), podemos simplificarlo as√≠:
```python
@funcion_decoradora
def zumbido():
	print("Buzzzzzz")
```
En solo tres l√≠neas de c√≥digo tenemos el mismo resultado que escribir zumbido = funcion_decoradora(zumbido).

<h2>¬øQu√© son getters y setters?</h2>

A diferencia de otros lenguajes de programaci√≥n, en Python los getters y setters tienen el objetivo de asegurar el encapsulamiento de datos. C√≥mo habr√°s visto, si declaramos una variable privada en Python, colocamos un guion bajo al inicio de esta (_), y normalmente son utilizados para: a√±adir l√≥gica de validaci√≥n al momento de obtener y definir un valor y, para evitar el acceso directo al campo de una clase.

La realidad es que en Python no existen variables netamente privadas, pues aunque se declaren con un guion bajo, podemos seguir accediendo a estas. En Programaci√≥n Orientada a Objetos esto es peligroso, pues podemos alterar el m√©todo de alguna clase y tener efectos colaterales que afecten la l√≥gica de nuestra aplicaci√≥n.

<h3>Clases sin getters y setters</h3>

Veamos un ejemplo con una clase que almacena un dato de distancia recorrida en millas (mi) y lo convierte a kil√≥metros (km):

```python
class Millas:
	def __init__(self, distancia = 0):
		self.distancia = distancia

	def convertir_a_kilometros(self):
		return (self.distancia * 1.609344)
```

Ahora creemos un objeto que haga referencia a un viaje:

```python
# Creamos un nuevo objeto
avion = Millas()

# Indicamos la distancia
avion.distancia = 200

# Obtenemos el atributo distancia
>>> print(avion.distancia)
200

# Obtenemos el m√©todo convertir_a_kilometros
>>> print(avion.convertir_a_kilometros())
321.8688
```

<h3>Utilizando getters y setters</h3>

Incluyamos un par de m√©todos para obtener la distancia y otro para que no acepte valores inferiores a cero, pues no tendr√≠a sentido que un veh√≠culo recorra una distancia negativa. Estos son m√©todos getters y setters:

```python
class Millas:
	def __init__(self, distancia = 0):
		self.distancia = distancia

	def convertir_a_kilometros(self):
		return (self.distancia * 1.609344)

	# M√©todo getter
	def obtener_distancia(self):
		return self._distancia

	# M√©todo setter
	def definir_distancia(self, valor):
		if valor < 0:
			raise ValueError("No es posible convertir distancias menores a 0.")
		self._distancia = valor
```

El m√©todo getter obtendr√° el valor de la distancia que y el m√©todo setter se encargar√° de a√±adir una restricci√≥n. Tambi√©n debemos notar c√≥mo distancia fue reemplazado por _distancia, denotando que es una variable privada.

Si probamos nuestro c√≥digo funcionar√°, la desventaja es que cualquier aplicaci√≥n que hayamos creado con una base similar deber√° ser actualizada. Esto no es nada escalable si tenemos cientos o miles de l√≠neas de c√≥digo.

<h2>Funci√≥n property()</h2>

Esta funci√≥n est√° incluida en Python, en particular crea y retorna la propiedad de un objeto. La propiedad de un objeto posee los m√©todos **getter(), setter() y del()**.

En tanto, la funci√≥n tiene cuatro atributos: **property(fget, fset, fdel, fdoc)**:

* fget: trae el valor de un atributo.
* fset: define el valor de un atributo.
* fdel: elimina el valor de un atributo.
* fdoc: crea un docstring por atributo.

Veamos un ejemplo del mismo caso implementando la funci√≥n property():

```python
class Millas:
	def __init__(self):
		self._distancia = 0

	# Funci√≥n para obtener el valor de _distancia
	def obtener_distancia(self):
		print("Llamada al m√©todo getter")
		return self._distancia

	# Funci√≥n para definir el valor de _distancia
	def definir_distancia(self, recorrido):
		print("Llamada al m√©todo setter")
		self._distancia = recorrido

	# Funci√≥n para eliminar el atributo _distancia
	def eliminar_distancia(self):
		del self._distancia

	distancia = property(obtener_distancia, definir_distancia, eliminar_distancia)

# Creamos un nuevo objeto
avion = Millas()

# Indicamos la distancia
avion.distancia = 200

# Obtenemos su atributo distancia
>>> print(avion.distancia)
Llamada al m√©todo getter
Llamada al m√©todo setter
200
```

Aunque en este ejemplo hay una sola llamada a print, tenemos tres l√≠neas como salida, pues esta llama a los primeros dos m√©todos. Por lo que la propiedad distancia es una propiedad de objeto que ayuda a mantener el acceso de forma privada.

<h2>Decorador @property</h2>

Este decorador es uno de varios con los que ya cuenta Python, el cual nos permite utilizar getters y setters para hacer m√°s f√°cil la implementaci√≥n de la programaci√≥n orientada a objetos en Python cambiando los m√©todos o atributos de las clases de forma que no modifiquemos el c√≥digo.

Pero mejor veamos un ejemplo en acci√≥n:

```python
class Millas:
	def __init__(self):
		self._distancia = 0

	# Funci√≥n para obtener el valor de _distancia
	# Usando el decorador property
	@property
	def obtener_distancia(self):
		print("Llamada al m√©todo getter")
		return self._distancia

	# Funci√≥n para definir el valor de _distancia
	@obtener_distancia.setter
	def definir_distancia(self, valor):
		if valor < 0:
			raise ValueError("No es posible convertir distancias menores a 0.")
		print("Llamada al m√©todo setter")
		self._distancia = valor

# Creamos un nuevo objeto
avion = Millas()

# Indicamos la distancia
avion.distancia = 200

# Obtenemos su atributo distancia
>>> print(avion.definir..distancia)
Llamada al m√©todo getter
Llamada al m√©todo setter
200
```

De esta manera usamos el decorador @property para utilizar getters y setters de una forma m√°s prolija e incluimos una nueva funcionalidad a nuestro m√©todo definir_distancia(), al mismo tiempo protegemos el acceso a nuestras variables privadas y cumplimos con el principio de encapsulaci√≥n.

# Encapsulaci√≥n, Getters and Setters

* Encapsulaci√≥n 
    * Permite agrupar datos y su comportamiento. 
    * Controla el acceso a dichos datos.
    * Previene modificaciones no autorizadas.

```python 
class CasillaDeVotacion():

    def __init__(self, identificador, pais):
        self.__identificador = identificador
        self.__pais = pais
        self.__region = None
    
    @property
    def region(self):
        return self.__region
    
    @region.setter
    def region(self,region):
        if region in self.__pais:
            self.__region = region
        else:
            raise ValueError(f'La region {region} no es v√°lida en {self.__pais}')

>>> casilla = CasillaDeVotacion(123,['Ciudad de Mexico','Morelos])
>>> casilla.region
None
>>> casila.region = 'Ciudad de Mexico'
>>> casilla.region
'Ciudad de M√©xico
```

# Herencia 

* Permite modelar una jerarqu√≠a de clases 
* Permite compartir comportamiento com√∫n en la jerarqu√≠a 
* Al padre se le conoce como superclase y al hijo como subclase 

<p align="center"><img width=40% src="./pictures/herencia.webp"></p>

Un aspecto important√≠simo de la Herencia es la posibilidad de reutilizar c√≥digo. La reutilizaci√≥n es uno de los pilares de la POO, de manera que evitemos reinventar la rueda cada vez. Si tenemos un comportamiento que es com√∫n entre una serie de objetos de la misma categor√≠a, este comportamiento debe enviarse a un clase superior que permita compartirlo con sus clases hijas. Esto facilita la mantenibilidad del c√≥digo haci√©ndolo m√°s estable.

# Polimorfismo 

* La habilidad de tomar varias formas 
* En python , nos permite cambiar el comportamiento de una superclase para  adaptarlo a la subclase 

# Introducci√≥n a la Complejidad Algoritmica 

* ¬øPor qu√© comparamos la eficiencia de un algoritmo? 

* Complejidad temporal vs complejidad espacial 

* Podemos definirla como T(n)

## Aproximaciones 

* Cronometrar el tiempo en el que corre un algoritmo 
* Contar los pasos con una medida abstracta de operaci√≥n 
* Contar los pasos conforme nos aproximamos al infinito 

# Clases de Complejidad Logaritmica 

* O(1) Constante  		# O -> Output
* O(n) Lineal
* O(log n) Logar√≠tmica 
* O(nlog n) Log lineal 
* O(n**2) Polinomial
* O(2**n) Exponencial

# Algoritmos de B√∫squeda y Ordenanci√≥n 

## B√∫squeda Lineal 

* Busca en todos los elementos de manera secuencial 
* ¬øCu√°l es el peor caso? 

## B√∫squeda Binaria 

* Divide y conquista 
* El problema se divide en 2 en cada iteraci√≥n 
* ¬øCu√°l es el peor caso ? 

# Ordenamiento de Burbuja 

El ordenamiento de burbuja es un algoritmo que recorre r√°pidamente una lista que necesita ordenarse. Compara elementos adyacentes y los intercambia si est√°n en el orden incorrecto. Este procedimiento se repite hasta que no se requieren m√°s intercambios, lo que indica que la lista se encuentra ordenada. 

# Ordenamiento por Inserci√≥n 

El ordenamiento por inserci√≥n es uno de los algoritmos m√°s comunes que estudian
los Cient√≠ficos del C√≥mputo. Es intuitivo y f√°cil de implementar, pero es muy
ineficiente para listas de gran tama√±o.

Una de las caracter√≠sticas del ordenamiento por inserci√≥n es que ordena en ‚Äúsu
lugar.‚Äù Es decir, no requiere memoria adicional para realizar el ordenamiento
ya que simplemente modifican los valores en memoria.

La definici√≥n es simple:

Una lista es dividida entre una sublista ordenada y otra sublista desordenada.
Al principio, la sublista ordenada contiene un solo elemento, por lo que por
definici√≥n se encuentra ordenada.

A continuaci√≥n se evalua el primer elemento dentro la sublista desordenada para
que podamos insertarlo en el lugar correcto dentro de la lista ordenada.

La inserci√≥n se realiza al mover todos los elementos mayores al elemento que
se est√° evaluando un lugar a la derecha.

Continua el proceso hasta que la sublista desordenada quede vacia y, por lo
tanto, la lista se encontrar√° ordenada.

Veamos un ejemplo:

Imagina que tienes la siguiente lista de n√∫meros:

7, 3, 2, 9, 8

Primero a√±adimos 7 a la sublista ordenada:

7, 3, 2, 9, 8

Ahora vemos el primer elemento de la sublista desordenada y lo guardamos en
una variable para mantener el valor. A esa variable la llamaremos valor_actual.
Verificamos que 3 es menor que 7, por lo que movemos 7 un lugar a la derecha.

7, 7, 2, 9, 8 (valor_actual=3)

3 es menor que 7, por lo que insertamos el valor en la primera posici√≥n.

3, 7, 2, 9, 8

Ahora vemos el n√∫mero 2. 2 es menor que 7 por lo que lo movemos un espacio a la
derecha y hacemos lo mismo con 3.

3, 3, 7, 9, 8 (valor_actual=2)

Ahora insertamos 2 en la primera posici√≥n.

2, 3, 7, 9, 8

9 es m√°s grande que el valor m√°s grande de nuestra sublista ordenada por lo que
lo insertamos directamente en su posici√≥n.

2, 3, 7, 9, 8

El √∫ltimo valor es 8. 9 es m√°s grande que 8 por lo que lo movemos a la derecha:

2, 3, 7, 9, 9 (valor_actual=8)

8 es m√°s grande que 7, por lo que procedemos a insertar nuestro valor_actual.

2, 3, 7, 8, 9

Ahora la lista se encuentra ordenada y no quedan m√°s elementos en la sublista
desordenada.

Antes de ver la implementaci√≥n en Python, trata de implementarlo por ti mismo
y comp√°rtenos tu algoritmo en la secci√≥n de comentarios.

Esta es una forma de implementar el algoritmo anterior:

```Python
def ordenamiento_por_insercion(lista):

    for indice in range(1, len(lista)):
        valor_actual = lista[indice]
        posicion_actual = indice

        while posicion_actual > 0 and lista[posicion_actual - 1] > valor_actual:
            lista[posicion_actual] = lista[posicion_actual - 1]
            posicion_actual -= 1

        lista[posicion_actual] = valor_actual
```

# Ordenamiento por Mezcla

Es un algoritmo de divide y conquista. Primero divide una lista en partes iguales hasta que quedan sublistas de 1 o 0 elementos. Luego las recombina de forma ordenada. 

# Ambientes Virtuales 

* Permiten aislar el ambiente para poder instalar diversas versiones de paquetes 
* A partir de python3 se incluye en la librer√≠a est√°ndar en el m√≥dulo venv
* Ning√∫n ingeniero profesional de Python trabaja sin ellos 

# ¬ø Por qu√© graficar?

* Reconocimiento de patrones 
* Predicci√≥n de una Serie 
* Simplifica la interpretaci√≥n y las conclusiones acerca de los datos

